<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>q1jun2</title>
      <link href="/2022/03/31/12519881100d-q1jun/"/>
      <url>/2022/03/31/12519881100d-q1jun/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>q1jun</title>
      <link href="/2022/03/31/d12d9d808946-q1jun/"/>
      <url>/2022/03/31/d12d9d808946-q1jun/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之线性表中简单的顺序表</title>
      <link href="/2022/03/24/78d3e21aeb89-q1jun/"/>
      <url>/2022/03/24/78d3e21aeb89-q1jun/</url>
      
        <content type="html"><![CDATA[<h1 id="线性表-Linear-List"><a href="#线性表-Linear-List" class="headerlink" title="线性表(Linear List)"></a>线性表(Linear List)</h1><p>线性表是具有<code>相同数据类型</code>，每个数据元素<code>所占空间一样大</code>的n个数据元素的<code>有限</code>序列(有次序)。</p><p>L&#x3D;($a_1,a_2,…,a_i,a_{i+1},…,a_n$)</p><p>其中$a_i$是线性表中的“第i个”元素线性表中的<code>位序</code></p><p>$a_1$是表头元素；$a_n$是表尾元素。</p><p>除第一个元素外，每个元素有且仅有一个<code>直接前驱</code>；除最后一个元素外，每个元素有且仅有一个<code>直接后继</code>。</p><h2 id="0x01-线性表的常用实现函数："><a href="#0x01-线性表的常用实现函数：" class="headerlink" title="0x01 线性表的常用实现函数："></a>0x01 线性表的常用实现函数：</h2><p>InitList(&amp;L): 初始化表。构造一个空的线性表L，分配内存空间。<br>DestroyList(&amp;L)：销毁操作。销毁线性表，并释放线性表L所占用的内存空间。</p><p>ListInsert(&amp;L,i,e)：插入操作。在表L中的第i个位置上插入指定元素e。<br>ListDelete(&amp;L,i,&amp;e)：删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</p><p>LocateElem(L,e)：按值查找操作。在表L中查找具有给定关键字值的元素。<br>GetElem(L,i)：按位查找操作。获取表L中第i个位置的元素的值。</p><p>其他常用操作： Length(L)：求表长。返回线性表L的长度，即L中数据元素的个数。<br>PrintList(L)：输出操作。按前后顺序输出线性表L的所有元素值。<br>Empty(L)：判空操作。若L为空表，则返回true，否则返回false。</p><h2 id="0x02-顺序表"><a href="#0x02-顺序表" class="headerlink" title="0x02 顺序表"></a>0x02 顺序表</h2><p>顺序表是用<code>顺序存储</code>的方式实现线性表。</p><blockquote><p>顺序存储：</p><p>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现。</p></blockquote><p>顺序表的特点：</p><ol><li>随机访问，即可在O(1)的时间内找到第 i 个元素。</li><li>存储密度高，每个节点之存储数据元素。</li><li>扩展容量不方便(即便采用动态分配的方式实现，拓展长度的时间复杂度也比较高)。</li><li>插入、删除操作不方便，需要移动大量元素。</li></ol><h3 id="0x0201-顺序表–静态分配"><a href="#0x0201-顺序表–静态分配" class="headerlink" title="0x0201 顺序表–静态分配"></a>0x0201 顺序表–静态分配</h3><p>静态分配方式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10<span class="comment">//定义最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  ElemType data[MaxSize];<span class="comment">//用静态的“数组”来存放数据元素</span></span><br><span class="line">  <span class="type">int</span> length;<span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;SqList;<span class="comment">//顺序表的类型定义(静态分配方式)</span></span><br></pre></td></tr></table></figure><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10 <span class="comment">//定义最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * @description: 初始化顺序表 </span></span><br><span class="line"><span class="comment"> * @param &#123;SqList&amp;&#125; L</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(SqList&amp; L)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; MaxSize; i++) &#123;</span><br><span class="line">        L.data[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    SqList L; <span class="comment">//声明一个顺序表</span></span><br><span class="line">    InitList(L); <span class="comment">//初始化顺序表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>;i &lt; L.length; i++) &#123; <span class="comment">//打印整个 data 数组</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;data[%d]=%d\n&quot;</span>, i, L.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//最好使用 GetElem(L , i)这种方式来访问顺序表的数据元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>顺序表的静态分配的局限性在于顺序表的表长在开始时就要确定，然后就无法更改（存储空间是<code>静态</code>的）。</p></blockquote><h3 id="0x0202-顺序表–动态分配"><a href="#0x0202-顺序表–动态分配" class="headerlink" title="0x0202 顺序表–动态分配"></a>0x0202 顺序表–动态分配</h3><p>为了动态分配存储空间，提高内存空间的使用效率，可以采用动态分配的分配方式。</p><p>动态分配方式：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sqlist_dynamic</span> //顺序表的类型定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType* data; <span class="comment">//指向动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize; <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>动态分配：动态申请和释放内存空间。</p><ul><li>申请：malloc函数</li><li>释放：free函数</li></ul></blockquote><p>举个栗子：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 10 <span class="comment">//顺序表的初始长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>//顺序表的类型定义</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span>* data; <span class="comment">//指向动态分配数组的指针</span></span><br><span class="line">    <span class="type">int</span> MaxSize; <span class="comment">//顺序表的最大容量</span></span><br><span class="line">    <span class="type">int</span> length; <span class="comment">//顺序表的当前长度</span></span><br><span class="line">&#125;Sqlist_dynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** </span></span><br><span class="line"><span class="comment"> * @description: 初始化顺序表 </span></span><br><span class="line"><span class="comment"> * @param &#123;Sqlist_dynamic&amp;&#125; L</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(Sqlist_dynamic&amp; L)</span> &#123;</span><br><span class="line">    <span class="comment">//用 malloc 函数申请一片连续的存储空间</span></span><br><span class="line">    L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>(InitSize * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    L.length = <span class="number">0</span>;</span><br><span class="line">    L.MaxSize = InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** </span></span><br><span class="line"><span class="comment"> * @description: 增加动态数组的长度 </span></span><br><span class="line"><span class="comment"> * @param &#123;Sqlist_dynamic&amp;&#125; L</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; len</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IncreaseSize</span><span class="params">(Sqlist_dynamic&amp; L, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span>* p = L.data;</span><br><span class="line">    L.data = (<span class="type">int</span>*)<span class="built_in">malloc</span>((L.MaxSize + len) * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        L.data[i] = p[i]; <span class="comment">//将数据复制到新区域</span></span><br><span class="line">    &#125;</span><br><span class="line">    L.MaxSize = L.MaxSize + len; <span class="comment">//顺序表最大长度 + len</span></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//释放原来的内存空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Sqlist_dynamic L;</span><br><span class="line">    InitList(L);</span><br><span class="line">    <span class="comment">/* <span class="doctag">TODO:</span> 随意插入几个元素 */</span></span><br><span class="line">    IncreaseSize(L, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0x0203-顺序表的插入"><a href="#0x0203-顺序表的插入" class="headerlink" title="0x0203 顺序表的插入"></a>0x0203 顺序表的插入</h3><h4 id="实现："><a href="#实现：" class="headerlink" title="实现："></a>实现：</h4><p>举第一个栗子🌰：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** </span></span><br><span class="line"><span class="comment"> * @description: 顺序表的插入，将元素e插入i处</span></span><br><span class="line"><span class="comment"> * @param &#123;SqList&amp;&#125; L</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; i</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length;j &gt;= i;j--) &#123; <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e; <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++; <span class="comment">//长度加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处省略：</p><ul><li>判断i是否合法，即 <code>i</code> 在<code>[1,length+1]</code>。</li><li>判断顺序表是否存满，若存满则无法插入数据。</li><li>返回是否操作成功的提示。</li></ul><p>举第二个栗子🌰（改进后）：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** </span></span><br><span class="line"><span class="comment"> * @description: 顺序表的插入，将元素e插入i处</span></span><br><span class="line"><span class="comment"> * @param &#123;SqList&amp;&#125; L</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; i</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; e</span></span><br><span class="line"><span class="comment"> * @return &#123;bool&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListInsert_better</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//判断i的范围是否合法</span></span><br><span class="line">    <span class="keyword">if</span> (L.length &gt;= MaxSize) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//判断当前空间是否能放下e</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = L.length; j &gt;= i; j--) &#123; <span class="comment">//将第i个元素及之后的元素后移</span></span><br><span class="line">        L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.data[i - <span class="number">1</span>] = e; <span class="comment">//在位置i处放入e</span></span><br><span class="line">    L.length++; <span class="comment">//长度加1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//插入成功，返回true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度分析："><a href="#时间复杂度分析：" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h4><p><strong>最好情况</strong>：新元素插入到表尾，不需要移动元素。<br>i &#x3D; n + 1，循环0次；最好时间复杂度 &#x3D; $O(1)$</p><p><strong>最坏情况</strong>：新元素插入到表头，需要将n个元素全部向后移动<br>i &#x3D; 1，循环n次；最坏时间复杂度 &#x3D; $O(n)$</p><p><strong>平均情况</strong>：新元素插入到任何一个位置的概率相同，即 i &#x3D; 1,2,3,……,length+1 的概率都是$p &#x3D; 1&#x2F;(n+1)$<br>当i &#x3D; 1，循环n次；当i &#x3D; 2时，循环n - 1次；当i &#x3D; 3时，循环n - 2次；……当i &#x3D; n + 1时,循环0次。<br>平均循环次数 &#x3D; $np+(n-1)p+(n-2)p+……+1·p &#x3D; [\frac{n(n+1)}2]·[\frac{1}{n+1}]&#x3D;\frac{n}2$<br>$\therefore$ 平均时间复杂度 &#x3D; $O(n)$</p><h3 id="0x0204-顺序表的删除"><a href="#0x0204-顺序表的删除" class="headerlink" title="0x0204 顺序表的删除"></a>0x0204 顺序表的删除</h3><h4 id="实现：-1"><a href="#实现：-1" class="headerlink" title="实现："></a>实现：</h4><p>举个栗子🌰：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** </span></span><br><span class="line"><span class="comment"> * @description: 删除操作。删除表L中第i个位置的元素，并用e返回删除元素的值。</span></span><br><span class="line"><span class="comment"> * @param &#123;SqList&amp;&#125; L</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; i</span></span><br><span class="line"><span class="comment"> * @param &#123;int&amp;&#125; e</span></span><br><span class="line"><span class="comment"> * @return &#123;bool&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ListDelete</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, <span class="type">int</span>&amp; e)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//判断i的范围是否有效</span></span><br><span class="line">    e = L.data[i - <span class="number">1</span>]; <span class="comment">//将被删除的元素值赋值给e</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i;j &lt; L.length;j++) &#123; <span class="comment">//将第i个位置后的元素前移</span></span><br><span class="line">        L.data[j - <span class="number">1</span>] = L.data[j];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--; <span class="comment">//线性表长度减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//返回ture，删除操作成功。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度分析：-1"><a href="#时间复杂度分析：-1" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h4><p>删除操作的时间复杂度和插入操作的时间复杂度相同。</p><h3 id="0x0205-顺序表的查找-按位查找"><a href="#0x0205-顺序表的查找-按位查找" class="headerlink" title="0x0205 顺序表的查找(按位查找)"></a>0x0205 顺序表的查找(按位查找)</h3><h4 id="实现：-2"><a href="#实现：-2" class="headerlink" title="实现："></a>实现：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** </span></span><br><span class="line"><span class="comment"> * @description: 查找第i个元素，返回给定值.</span></span><br><span class="line"><span class="comment"> * @param &#123;SqList&#125; L</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; i</span></span><br><span class="line"><span class="comment"> * @return &#123;int&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ElemType <span class="title function_">GetElemByIndex</span><span class="params">(SqList L, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> L.data[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度分析：-2"><a href="#时间复杂度分析：-2" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h4><p>直接返回值，时间复杂度 &#x3D; $O\left(1\right)$</p><h3 id="0x0206-顺序表的查找-按值查找"><a href="#0x0206-顺序表的查找-按值查找" class="headerlink" title="0x0206 顺序表的查找(按值查找)"></a>0x0206 顺序表的查找(按值查找)</h3><h4 id="实现：-3"><a href="#实现：-3" class="headerlink" title="实现："></a>实现：</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*** </span></span><br><span class="line"><span class="comment"> * @description: 查找具有给定关键字值的元素</span></span><br><span class="line"><span class="comment"> * @param &#123;SqList&#125; L</span></span><br><span class="line"><span class="comment"> * @param &#123;int&#125; e</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">GetElemByValue</span><span class="params">(SqList L, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (L.data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">//数组下标为i的元素值等于e，返回其位序i+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//退出了循环，说明查找失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：C语言中不能用<code>==</code>来直接比较两个结构体变量。</p></blockquote><h4 id="时间复杂度分析：-3"><a href="#时间复杂度分析：-3" class="headerlink" title="时间复杂度分析："></a>时间复杂度分析：</h4><p><strong>最好情况</strong>：目标元素在表头。<br>循环1次；最好时间复杂度 &#x3D; $O(1)$</p><p><strong>最坏情况</strong>：目标元素在表尾<br>循环n次；最坏时间复杂度 &#x3D; $O(n)$</p><p><strong>平均情况</strong>：假设目标元素出现在任何一个位置的概率相同，概率都是$p &#x3D; \cfrac 1n$<br>平均循环次数 &#x3D; $1\cdot\cfrac1n+2\cdot\cfrac1n+3\cdot\cfrac1n+……+n\cdot\cfrac1n &#x3D; [\frac{n(n+1)}2]·[\frac{1}{n}]&#x3D;\frac{n+1}2$<br>$\therefore$ 平均时间复杂度 &#x3D; $O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> C语言 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
